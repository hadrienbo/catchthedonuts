char homer[] = {
0x00, 0x77, 0x77, 0x00, 
0x07, 0x11, 0x11, 0x70, 
0x07, 0xb1, 0xb1, 0x70, 
0x07, 0x77, 0x77, 0x70, 
0x07, 0x88, 0x88, 0x70, 
0x08, 0xbb, 0xbb, 0x80, 
0x08, 0xbb, 0xbb, 0x80, 
0x00, 0x88, 0x88, 0x00, 
0x00, 0x77, 0x77, 0x00, 
0x07, 0x11, 0x11, 0x70, 
0x07, 0x1b, 0x1b, 0x70, 
0x07, 0x77, 0x77, 0x70, 
0x07, 0x88, 0x88, 0x70, 
0x08, 0xbb, 0xbb, 0x80, 
0x08, 0x88, 0x88, 0x80, 
0x00, 0x88, 0x88, 0x00
};

char burns[] = {
0x00, 0x33, 0x33, 0x77, 0x77, 0x33, 0x33, 0x00, 
0x00, 0x33, 0x33, 0x77, 0x77, 0x33, 0x33, 0x00, 
0x00, 0x73, 0x3b, 0x77, 0x7b, 0x33, 0x37, 0x00, 
0x00, 0x73, 0x1b, 0xb7, 0xbb, 0x13, 0x70, 0x00, 
0x00, 0x03, 0x11, 0xb7, 0xb1, 0x13, 0x70, 0x00, 
0x00, 0x07, 0x77, 0xb7, 0xb7, 0x77, 0x70, 0x00, 
0x00, 0x07, 0x7b, 0x77, 0x7b, 0x77, 0x00, 0x00, 
0x00, 0x00, 0x7b, 0x77, 0x7b, 0x77, 0x00, 0x00, 
0x00, 0x00, 0x77, 0xb7, 0xb7, 0x70, 0x00, 0x00, 
0x00, 0x00, 0x77, 0xbb, 0xb7, 0x70, 0x00, 0x00, 
0x00, 0x00, 0x11, 0xbb, 0x77, 0x10, 0x00, 0x00, 
0x00, 0x00, 0x01, 0x77, 0x71, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x07, 0x11, 0x11, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x66, 0xfa, 0xf6, 0x60, 0x00, 0x00, 
0x00, 0x06, 0x66, 0xaa, 0xa6, 0x66, 0x00, 0x00, 
0x00, 0x06, 0x66, 0xaa, 0xa6, 0x66, 0x00, 0x00
};

char donut[] = {
0x07, 0x22, 0x22, 0x70, 
0x72, 0x22, 0x22, 0x27, 
0x22, 0x27, 0x72, 0x22, 
0x22, 0x70, 0x07, 0x22, 
0x22, 0x70, 0x07, 0x22, 
0x22, 0x27, 0x72, 0x22, 
0x72, 0x22, 0x22, 0x27, 
0x07, 0x22, 0x22, 0x70
};

char uranium[] = {
0x00, 0x00, 0xdd, 0x55, 
0x00, 0x0d, 0xd5, 0x55, 
0x00, 0xdd, 0x55, 0x59, 
0x00, 0xd5, 0x55, 0x90, 
0x0d, 0x55, 0x59, 0x00, 
0xd5, 0x55, 0x59, 0x00, 
0xd5, 0x55, 0x90, 0x00, 
0xd9, 0x99, 0x00, 0x00
};

char explode1[] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 
0x00, 0xa0, 0xa0, 0xa5, 0x00, 0x5a, 0x00, 0x00, 
0x0a, 0x00, 0x05, 0xaa, 0xa5, 0xaa, 0x50, 0xa0, 
0x00, 0xa0, 0x55, 0x52, 0x2a, 0x55, 0x55, 0x00, 
0x00, 0x05, 0x55, 0x15, 0x2a, 0xa5, 0x00, 0xa0, 
0x00, 0x55, 0xa5, 0x51, 0x55, 0x55, 0x55, 0x00, 
0x05, 0xaa, 0x22, 0x5a, 0xa1, 0x52, 0x50, 0x50, 
0x05, 0x52, 0x25, 0x52, 0x2a, 0x52, 0x25, 0x50, 
0x00, 0xa2, 0x51, 0xaa, 0x25, 0x25, 0x1a, 0xa0, 
0x00, 0x5a, 0x15, 0x5a, 0xa2, 0x22, 0x5a, 0x50, 
0x0a, 0x05, 0xa1, 0x51, 0x52, 0x55, 0x50, 0x00, 
0x00, 0x00, 0x55, 0x15, 0x2a, 0xa5, 0x0a, 0x00, 
0x0a, 0x00, 0x05, 0xa2, 0x2a, 0xc0, 0xa0, 0x00, 
0x00, 0xa0, 0xa0, 0xaa, 0xaa, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x0a, 0xa0, 0xc0, 0xaa, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

char explode2[] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 
0x00, 0xc0, 0xc0, 0xcc, 0x00, 0xcc, 0x00, 0x00, 
0x0c, 0x00, 0x0c, 0xcc, 0xcc, 0xcc, 0xc0, 0xc0, 
0x00, 0xc0, 0xcc, 0xc1, 0x1a, 0xcc, 0xcc, 0x00, 
0x00, 0x0c, 0xcc, 0x15, 0x1a, 0xac, 0x00, 0xc0, 
0x00, 0xcc, 0xa5, 0x51, 0x55, 0x5c, 0xcc, 0x00, 
0x0c, 0xca, 0x11, 0x5a, 0xa1, 0x51, 0xc0, 0xc0, 
0x0c, 0xc1, 0x15, 0x52, 0x2a, 0x51, 0x1c, 0xc0, 
0x00, 0xc1, 0x51, 0xaa, 0x25, 0x15, 0x1c, 0xc0, 
0x00, 0xcc, 0x15, 0x5a, 0xa1, 0x11, 0xcc, 0xc0, 
0x0c, 0x0c, 0xc1, 0x51, 0x51, 0x5c, 0xc0, 0x00, 
0x00, 0x00, 0xcc, 0x15, 0x1a, 0xac, 0x0c, 0x00, 
0x0c, 0x00, 0x0c, 0xa1, 0x1a, 0xc0, 0xc0, 0x00, 
0x00, 0xc0, 0xc0, 0xcc, 0xcc, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x0c, 0xc0, 0xc0, 0xcc, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

char music[] = "E:d=5,o=4,b=250:2f5,4a5,4b5,5d6,3c6,3a5,4f5,4d5,2b4,2c5";

char ground[] = {
0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 
0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 
0x68, 0xcc, 0xcc, 0xcc, 0x68, 0xcc, 0xcc, 0xcc, 0x68, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 
0x68, 0xcc, 0xcc, 0xcc, 0x68, 0xcc, 0xcc, 0xcc, 0x68, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 
0x6c, 0xcc, 0xcc, 0xc8, 0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xc8, 0x6c, 0xcc, 0x8c, 0xcc, 
0x6c, 0xcc, 0xcc, 0x8c, 0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 
0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0x8c, 0xcc, 0x6c, 0xcc, 0x8c, 0xcc, 
0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 
0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 
0x6c, 0x88, 0x8c, 0xcc, 0x68, 0x8c, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 0x68, 0x8c, 0xcc, 0xcc, 
0x6c, 0xcc, 0xcc, 0xcc, 0x68, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 0x68, 0xcc, 0xcc, 0xcc, 
0x6c, 0xcc, 0xcc, 0xcc, 0x68, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 0x68, 0xcc, 0xcc, 0xcc, 
0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 
0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0x88, 0x6c, 0xcc, 0xcc, 0xcc, 
0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xc8, 0x6c, 0xcc, 0xcc, 0xcc, 
0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 
0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 
0x6c, 0xc8, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 
0x6c, 0x8c, 0xcc, 0xc8, 0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0x8c, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 
0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xc8, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 
0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0x8c, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 
0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0x8c, 0xcc, 0x6c, 0xcc, 0xcc, 0xc8, 
0x6c, 0x8c, 0xcc, 0xcc, 0x6c, 0x8c, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0x8c, 
0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 
0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0x8c, 
0x68, 0xcc, 0xcc, 0xc8, 0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xc8, 0xcc, 
0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 
0x6c, 0xcc, 0xcc, 0xc8, 0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 0x68, 0xcc, 0xcc, 0xcc, 
0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 
0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0xc8, 0x6c, 0xcc, 0xcc, 0xcc, 
0x6c, 0xcc, 0x88, 0xcc, 0x6c, 0xcc, 0xcc, 0xcc, 0x6c, 0xcc, 0xcc, 0x88, 0x6c, 0xcc, 0xcc, 0xcc, 
0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66
};

int field[] = {
	ground, ground, ground, ground,
	ground, ground, ground, ground,
	ground, ground, ground, ground,
	ground, ground, ground, ground,
	ground, ground, ground, ground,
	ground, ground, ground, ground,
	ground, ground, ground, ground,
	ground, ground, ground, ground
}


int frame = 0, key, x, y; 			// variables of int type (occupy two bytes in memory): frame - number of the frame to be drawn, key - number of the button pressed, x - position in x axis, y - position in y axis.

int level = 0, levelmax = 2;
int score = 0;
int tabdonutlevel[] = {5, 10, 17};
int taburaniumlevel[] = {5, 8, 10};
	
int countdonut, countsprite;		// Compteurs des sprites.

int didIWin = 1;						// si toujours a 1 quand y'a plus de donnuts, on gagne.
int time = 0, maxtime = 50;
int isTimeover=0;



/*
*	Methode de collision des sprites 'burns'.
*	Si collision avec Homer, la partie est perdue.
*
*/
void burnscollision(int n)
{
	if(spritegetvalue(n, S_COLLISION) == 1 )
	{            
		didIWin = 0;
	}	
}

/*
*	Methode de collision des sprites 'homer'.
*	Si collision avec burns, la partie est perdue.
*
*/
void homercollision(int n)
{
	if(spritegetvalue(n, S_COLLISION) == 2 )
	{            
		didIWin = 0;
	}	
}


/*
*	Methode appelée losrque le sprite 'burns' sort de l'ecran.
*	'burns' a alors 2/3 de chances d'apparaitre du coté ou il a disparut, 1/3 de chances d'apparaitre de l'autre cote.
*	la position en y et la vitesse de 'burns' peut etre legerement modifie, aleatoirement.
*
*/
void burnsexitscreen(int n)
{
	if( spritegetvalue(n, S_X) > 127 && spritegetvalue(n, S_SPEEDX) > 0)
	{		
		if(random(2) >= 1)
		{			
			spritesetvalue(n, S_Y, random(112));	
			spritesetvalue(n, S_X, 136);
		
			spritesetvalue(n, S_SPEEDX,  -8 - level - (level * random(3)));
		} 	
		else
		{
			spritesetvalue(n, S_Y, random(112));	
			spritesetvalue(n, S_X, -20);
		
			spritesetvalue(n, S_SPEEDX,  8 + level + (level * random(3)));
		}
	}
	else if( spritegetvalue(n, S_X) < 0 && spritegetvalue(n, S_SPEEDX) < 0)
	{
		if(random(2) >= 1)
		{			
			spritesetvalue(n, S_Y, random(112));	
			spritesetvalue(n, S_X, -20);
		
			spritesetvalue(n, S_SPEEDX,  -8 - level - (level * random(3)));
		} 	
		else
		{			
			spritesetvalue(n, S_Y, random(112));	
			spritesetvalue(n, S_X, 136);
		
			spritesetvalue(n, S_SPEEDX,  8 + level + (level * random(3)) );
		}
	}
	
}




/*
*	Methode de collision des sprites 'donut'.
*	Si collision avec Homer, le sprite disparait et countDonut baisse.
*
*/
void donutcollision(int n)

{
	if(spritegetvalue(n, S_COLLISION)  > 2 )
	{
		// Le sprite a pop sur un autre sprite, on le deplace.
		putsprite(n, 20 + random(100), 20 + random(100));
	}	
	
	else if(spritegetvalue(n, S_COLLISION) == 1 )
	{            
		// Si collision avec le sprite 'homer', le donut disparait.
			
		spritesetvalue(n, S_LIVES, 0);
		countdonut --;

	}	
}




/*
*	Methode de collision des sprites 'uranium'.
*	Si collision avec Homer, le sprite explose, on fait disparaitre les autres sprites, et didIWin passe a 0.
*
*/
void uraniumcollision(int n)
{
	if(spritegetvalue(n, S_COLLISION)  > 2 )
	{
		// Le sprite a pop sur un autre sprite, on le deplace.
		putsprite(n, 20 + random(100), 20 + random(100));
	}
	
	else if(spritegetvalue(n, S_COLLISION) == 1 )
	{
		spritesetvalue(1, S_LIVES, 0);		// On supprime le sprite 'homer'
		
		spritesetvalue(n, S_WIDTH, 16);		// On change la taille du sprite 'uranium' pour la taille du sprite 'explosion'.
		spritesetvalue(n, S_HEIGHT, 16);
		
		putsprite(n, spritegetvalue(n, S_X) - 4, spritegetvalue(n, S_Y) - 4); 		// On recentre le sprite.
		
		// BOOM 
		getsprite(n, explode1);
		delayredraw();
		delayredraw();
		delayredraw();
		delayredraw();
		getsprite(n, explode2);
		delayredraw();
		delayredraw();
		delayredraw();
		delayredraw();

		getsprite(n, explode1);
		delayredraw();
		delayredraw();
		delayredraw();
		delayredraw();
		getsprite(n, explode2);
		
		didIWin = 0;
	}
}




/*
*	Load les tuiles du fond, place les sprites.
*
*/
void init()
{
	clearscreen();
	loadrtttl(music,0);
	playrtttl();
	gotoxy(3, 3);	
	printf("Catch the donuts!");
	
	gotoxy(7, 6);	
	printf("Level %d!", level + 1);
	
	countdonut = tabdonutlevel[level];
	countsprite = countdonut + taburaniumlevel[level];
	
	while (getkey() == 0)
	{
	}

	clearscreen();

	loadtile(field, 32, 32, 4, 4);	
	drawtile(0,0);
		
    x = 3; // Homer commence en haut à gauche
    y = 3;
	
    getsprite(1, homer);		// creation du sprite homer.
	countsprite++;
	
	getsprite(2, burns);		// creation du sprite burns.
	countsprite++;

	for(int i = 3; i <= countsprite; i++)
	{
		int xi = 20 + random(100); // +20 pour pas pop sur le sprite 'homer'.
		int yi = 20 + random(100);
				
		if( i <= countdonut + 2)
		{
			getsprite(i, donut);
			spritesetvalue(i, S_ON_COLLISION, donutcollision);		
		}			
		else
		{
			// 1/3 des sprites sera des barres d'uraniums.
			getsprite(i, uranium);
			spritesetvalue(i, S_ON_COLLISION, uraniumcollision);
		}
		putsprite(i, xi , yi);
	}	
		
	// On initialise les valeurs de 'burns'.
	spritesetvalue(2, S_WIDTH, 16);
	spritesetvalue(2, S_HEIGHT, 16);
	spritesetvalue(2, S_ON_COLLISION, homercollision);
	spritesetvalue(2, S_ON_COLLISION, burnscollision);
	spritesetvalue(2, S_ON_EXIT_SCREEN, burnsexitscreen);
	
	putsprite(2, 132, 20 + random(92));

	spritesetvalue(2, S_SPEEDX, -8 - level - (level * random(3)));
}
	
	
	
	
	
/*
*	Cette methode gere les deplacements du sprite 'homer', selon la touche du clavier appuyée.
*/
void step()
{
    if(!gettimer(0)) 		// change the frame from 0 to 1 and back each 400 milliseconds.
	{
        settimer(0, 400);
        frame = 1 - frame;
    }

    key = getkey(); 		// get the buttons pressed
    if(key == KEY_UP)
	{
        y--; 				// if the up button is pressed, move Homer up, similar to other buttons
		if(y<0)
			y=31;
    }
    if(key == KEY_DOWN)
	{
        y++;
		if(y>31)
			y=0;
    }
    if(key == KEY_LEFT) 
	{
        x--;
		if(x<0)
			x=31;
    }
    if(key == KEY_RIGHT) 
	{
        x++;
		if(x>31)
			x=0;
    }
}





/*
*	Affiche le compteur de temps a l'ecran. Quand il arrive a 0, passe didIWin a 0.
*
*/
void printTime()
{
    if(gettimer(1) == 0)
	{
        settimer(1, 1000);
        time++;
        gotoxy(1,1);
		
		if((maxtime - time) % 60 >= 10)
        	printf("%d:%d ", (maxtime - time) / 60, (maxtime - time) % 60);
		else
			printf("%d:0%d ", (maxtime - time) / 60, (maxtime - time) % 60); // On doit rajouter le 0 des dizaines.
			
		if((time / maxtime)==1)
		{
			isTimeover=1;
			didIWin=0;
		}
    }
}





/*
*	Cette methode est appelee après step, elle redessine le sprite 'homer' a la nouvelle position determinee par step().
*
*/
void draw()
{
    getsprite(1, homer + frame * 32);
    putsprite(1, x * 4, y * 4); 
    delayredraw();
}




/*
*	Supprime tous les sprites.
*
*/
void clearsprites()
{
	int i = countsprite;
	while(i > 0)
	{
		spritesetvalue(i, S_LIVES, 0);
		i--;
	}
}




/*
*	Affiche l'ecran de fin.
*
*/
void end()
{
	clearsprites();
	
	clearscreen();
	if(didIWin == 1)
	{
		puts("you win!!");
		gotoxy(7, 4);
		printf("score: %d", score);
	}

	else
	{
		puts("you lose!!");
		gotoxy(7, 4);
		printf("score: %d", score);
	}
}




void main()
{
	while( level <= levelmax  && isTimeover==0 && didIwin)
	{
    	init();

    	while(countdonut > 0 && isTimeover==0 && didIwin)
		{
			printTime();
    	    step();	
    	    draw();
    	}		
		clearsprites()
		
		if (didIwin == 1)
			score += (maxtime - time);
		level++;
	}
	
	end();
}
